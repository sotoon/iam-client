// The following directive is necessary to make the package coherent:
//go:build ignore
// +build ignore

// This program generates mock.gen.go. It can be invoked by running
// go generate.
// NOTE: This code expects Client interface exists in separated file.
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var (
	srcPath       = "../interface.go"
	destPath      = "./mock.gen.go"
	interfaceName = "Client"
	mockedName    = "MockedClient"

	fset *token.FileSet
	src  *bytes.Buffer
)

func main() {
	srcBytes, err := ioutil.ReadFile(srcPath)
	if err != nil {
		fatalf(token.NoPos, "error reading file: %v", err)
	}
	src = bytes.NewBuffer(srcBytes)

	fset = token.NewFileSet()
	f, err := parser.ParseFile(fset, srcPath, src, 0)
	if err != nil {
		fatalf(token.NoPos, "error parsing file: %v", err)
	}

	iface := getInterface(interfaceName, f)
	if iface == nil {
		absPath, _ := filepath.Abs(srcPath)
		fatalf(token.NoPos, "%q interface not found in: %s", interfaceName, absPath)
	}
	ifaceFuncs := interfaceFuncMap(iface)

	parts := []string{
		"// This file is generated by gen.go",
		"package mock",
	}
	parts = append(parts, generateImports(
		[]string{"git.cafebazaar.ir/infrastructure/iam/bepactl/pkg/client"},
		f.Imports))
	parts = append(parts, generateStruct(mockedName, interfaceName, ifaceFuncs))
	ifaceFuncs.iterateSorted(func(methodName string, funcType *ast.FuncType) {
		parts = append(parts, generateMethod(mockedName, methodName, funcType))
	})

	generated := []byte(strings.Join(parts, "\n\n"))
	generated, err = format.Source(generated)
	if err != nil {
		fatalf(token.NoPos, "error formatting code: %v", err)
	}

	err = ioutil.WriteFile(destPath, generated, 0666)
	if err != nil {
		fatalf(token.NoPos, "error writing file: %v", err)
	}
}

func generateImports(defaults []string, imports []*ast.ImportSpec) string {
	const gen = `import (
%s
)`
	gimports := defaults
	for i, s := range gimports {
		gimports[i] = fmt.Sprintf(". %q", s)
	}
	for _, spec := range imports {
		gimport := spec.Path.Value
		if spec.Name != nil && spec.Name.Name != "" {
			gimport = fmt.Sprintf("%s %s", spec.Name.Name, gimport)
		}
		gimport = gimport
		gimports = append(gimports, gimport)
	}
	return fmt.Sprintf(gen, strings.Join(gimports, "\n"))
}

type ifaceFuncsType map[string]*ast.FuncType

func (ft ifaceFuncsType) iterateSorted(f func(k string, v *ast.FuncType)) {
	type pair struct {
		key   string
		value *ast.FuncType
	}
	slice := make([]pair, 0, len(ft))
	for k, v := range ft {
		slice = append(slice, pair{k, v})
	}
	sort.Slice(slice, func(i, j int) bool {
		return slice[i].key < slice[j].key
	})
	for _, p := range slice {
		f(p.key, p.value)
	}
}

func generateStruct(name, ifaceName string, ifaceFuncs ifaceFuncsType) string {
	const gen = `type %s struct {
%s
}

var _ %s = (*%s)(nil)`

	fields := []string{"Context Context", ""}
	ifaceFuncs.iterateSorted(func(name string, funcType *ast.FuncType) {
		mockedFuncName := fmt.Sprintf("%sFunc", name)
		paramsList := append([]string{"ctx Context"}, variableList(funcType.Params)...)
		params := strings.Join(paramsList, ", ")

		resultsList := variableList(funcType.Results)
		results := strings.Join(resultsList, ", ")
		if !justType(funcType.Results) {
			results = fmt.Sprintf("(%s)", results)
		}

		fields = append(fields, fmt.Sprintf("%s func(%s) %s", mockedFuncName, params, results))

	})

	return fmt.Sprintf(gen, name, strings.Join(fields, "\n"), ifaceName, name)
}

func generateMethod(structName, funcName string, funcType *ast.FuncType) string {
	const gen = `func (m *%s) %s(%s) %s {
%s
}`

	mustHaveNames(funcType.Params)
	paramsList := variableList(funcType.Params)
	paramNames := variableListNames(funcType.Params)
	params := strings.Join(paramsList, ", ")

	resultsList := variableList(funcType.Results)
	results := strings.Join(resultsList, ", ")
	if !justType(funcType.Results) {
		results = fmt.Sprintf("(%s)", results)
	}

	mockedFuncName := fmt.Sprintf("%sFunc", funcName)
	nilPanic := fmt.Sprintf(`if m.%s == nil { panic("not implemented") }`, mockedFuncName)
	callParams := append([]string{"m.Context"}, paramNames...)
	callReturnStr := fmt.Sprintf("m.%s(%s)",
		mockedFuncName, strings.Join(callParams, ", "))
	if len(resultsList) > 0 {
		callReturnStr = fmt.Sprintf("return %s", callReturnStr)
	}
	body := strings.Join([]string{nilPanic, callReturnStr}, "\n")

	return fmt.Sprintf(gen,
		structName, funcName, params, results, body)
}

func justType(list *ast.FieldList) bool {
	if list == nil {
		return true
	}
	if len(list.List) > 1 {
		return false
	}
	for _, item := range list.List {
		if item.Names != nil && len(item.Names) > 0 {
			return false
		}
	}
	return true
}

func variableList(list *ast.FieldList) []string {
	genparams := []string{}
	if list == nil {
		return genparams
	}
	for _, param := range list.List {
		names := []string{}
		for _, varName := range param.Names {
			names = append(names, varName.Name)
		}

		typ := getType(param.Type)
		if len(names) > 0 {
			genparams = append(genparams,
				fmt.Sprintf("%s %s", strings.Join(names, ", "), typ))
		} else {
			genparams = append(genparams, typ)
		}
	}
	return genparams
}

func variableListNames(list *ast.FieldList) []string {
	vars := []string{}
	if list == nil {
		return vars
	}
	for _, item := range list.List {
		for _, varName := range item.Names {
			vars = append(vars, varName.Name)
		}
	}
	return vars
}

func interfaceFuncMap(iface *ast.InterfaceType) ifaceFuncsType {
	if iface == nil {
		return nil
	}
	outp := make(ifaceFuncsType)
	if iface.Methods == nil || len(iface.Methods.List) <= 0 {
		return outp
	}
	for _, method := range iface.Methods.List {
		name := method.Names[0].Name
		typ := method.Type.(*ast.FuncType)
		if isTitle(name) {
			outp[name] = typ
		}
	}
	return outp
}

func getInterface(name string, file *ast.File) *ast.InterfaceType {
	var outp *ast.InterfaceType
	ast.Inspect(file, func(n ast.Node) bool {
		typeDecl, ok := n.(*ast.GenDecl)
		if !ok || typeDecl.Tok != token.TYPE {
			return true
		}
		for _, declSpec := range typeDecl.Specs {
			typeSpec, ok := declSpec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if typeSpec.Name.String() != name {
				continue
			}
			ifaceType, ok := typeSpec.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}
			outp = ifaceType
			return false
		}
		return true
	})
	return outp
}

func getType(typ ast.Expr) string {
	return string(src.Bytes()[typ.Pos()-1 : typ.End()-1])
}

func mustHaveNames(varList *ast.FieldList) {
	for _, param := range varList.List {
		if param.Names == nil || len(param.Names) <= 0 {
			fatalf(param.Pos(), "all interface methods should have name for variables")
		}
	}
}

func fatalf(pos token.Pos, format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "%s: %s\n", fset.Position(pos).String(), fmt.Sprintf(format, args...))
	os.Exit(1)
}

func isTitle(s string) bool {
	return s[0] >= 'A' && s[0] <= 'Z'
}
